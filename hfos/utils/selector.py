#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

# Hackerfleet Technology Demonstrator
# =====================================================================
# Copyright (C) 2011-2014 riot <riot@hackerfleet.org> and others.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


__author__ = 'riot'
import time

from Axon.Component import component
from Axon.AdaptiveCommsComponent import AdaptiveCommsComponent
from Axon.Ipc import producerFinished, shutdownMicroprocess
from Kamaelia.Chassis.Pipeline import Pipeline
from Kamaelia.Util.DataSource import DataSource
from Kamaelia.Util.Console import ConsoleEchoer

from hfos.utils.logger import log, debug, warn


class PipeSelector(AdaptiveCommsComponent):
    """
    Given a routing list like this:
     [(MessageMatchingFunction, ComponentGenerator),
      ...
     ]
    routes incoming Messages by running every MessageMatchFunction on it.
    If any of the MessageMatchingFunctions returns True,
    1. A new Component is generated by the matching ComponentGenerator
    2. The PipeSelector ties this new component into a created message loop
    3. The component is activated and gets the message fed
    4. Upon producerFinished, the component will be torn down and links deleted
    5. Any resulting output will be sent to the PipeSelector's outbox

    *** NOTICE *************************************************************
    * Those pipes MUST finish in reasonable time, otherwise they get stopped
    and an unanswered request is the result!
    * The ComponentGenerator MUST be a callable, returning an AxonComponent
      or alike
    * The MessageMatchingFunction may be something like this:
      lambda x: x['foobar'] == 'bazqux' # TODO: Enhance this!
    ************************************************************************
    """

    Inboxes = {"inbox": "Items",
               "control": "Shutdown signalling",
    }
    Outboxes = {"outbox": "Items tagged with a sequence number, in the form (seqnum, item)",
                "signal": "Shutdown signalling",
    }

    def __init__(self, routes, defaultpipe=None):
        super(PipeSelector, self).__init__()
        self.routes = routes  # [(condition, pipeline), ...]
        self.defaultpipe = defaultpipe


    def finished(self):
        while self.dataReady("control"):
            msg = self.recv("control")
            if type(msg) in (shutdownMicroprocess, producerFinished):
                self.send(msg, "signal")
                return True
        return False


    def main(self):
        """Main loop."""

        while not self.finished():
            while not self.dataReady("inbox"):
                self.pause()
                yield 1
            data = self.recv("inbox")

            log("[PS] data: ", data,lvl=debug)

            direction = hit = False


            for condition, pipegen in self.routes:
                if condition(data):
                    hit = True
                    direction = pipegen

            if not hit:
                if self.defaultpipe:
                    log("[PS] No hit, running through defaultpipe.",lvl=debug)
                    direction = self.defaultpipe

            if direction:
                log("[PS] Generating pipe", lvl=debug)

                pipe = direction()
                #component(pipe).initialiseComponent()

                log("[PS] Generating boxes.",lvl=debug)

                self.addOutbox(pipe.name)
                self.addOutbox(pipe.name + "signal")
                self.addInbox(pipe.name + "control")
                self.addInbox(pipe.name + "inbox")

                log("[PS] Generating links.",lvl=debug)

                thetolink = self.link((self, pipe.name), (pipe, "inbox"))
                thefromlink = self.link((pipe, "outbox"), (self, pipe.name + "inbox"))
                thetosignal = self.link((self, pipe.name + "signal"), (pipe, "control"))
                thefromsignal = self.link((pipe, "signal"), (self, pipe.name + "control"))

                log("[PS] Transmitting data to pipe:", data, lvl=debug)

                self.send(data, pipe.name)
                pipe.activate()
                self.send(producerFinished, pipe.name + "signal")

                def clearLinks():
                    #log("[PS] Unlinking..")

                    self.unlink(pipe, thetolink)
                    self.unlink(pipe, thefromlink)
                    self.unlink(pipe, thetosignal)
                    self.unlink(pipe, thefromsignal)

                begin = time.time()
                #component(pipe)._callOnCloseDown.append(clearLinks)
                #while (not component(pipe)._isStopped()) and (time.time() < begin + 5):
                #    yield 1

                while (not self.dataReady(pipe.name + "inbox")) and (time.time() < begin + 1):
                    yield 1

                if self.dataReady(pipe.name + "inbox"):
                    self.send(self.recv(pipe.name + "inbox"), "outbox")
                else:
                    log("[PS] WARNING: Pipe didn't respond in time: ", pipe.name, pipe, lvl=warn)

                #log("[PS] Pipe sent signal:", self.recv(pipe.name+"control")
                #)
                clearLinks()
                component(pipe).closeDownComponent()
                self.deleteOutbox(pipe.name)
                self.deleteOutbox(pipe.name + "signal")
                self.deleteInbox(pipe.name + "control")
                self.deleteInbox(pipe.name + "inbox")

                log("[PS] Done.",lvl=debug)

            else:
                log("[PS] No match, no default",lvl=warn)


def testPipeSelector():
    from Kamaelia.Util.PureTransformer import PureTransformer

    def hitLine(hit):
        return (lambda x: x == hit, Pipeline(
            PureTransformer(lambda x: "YAY! Detected " + hit + " in " + str(x))
        )
        )

    rules = [hitLine("foo"),
             hitLine("bar")
    ]

    test = Pipeline(DataSource(["baz", "foo", "bar", "qux"]),
                    PipeSelector(rules),
                    PureTransformer(lambda x: "YAY! This is what you get:" + str(x)),
                    ConsoleEchoer()
    ).activate()