__author__ = 'riot'
import time

from Axon.Component import component
from Axon.AdaptiveCommsComponent import AdaptiveCommsComponent
from Axon.Ipc import producerFinished, shutdownMicroprocess
from Kamaelia.Chassis.Pipeline import Pipeline
from Kamaelia.Util.DataSource import DataSource
from Kamaelia.Util.Console import ConsoleEchoer

from weatherscraper.logging import log


class PipeSelector(AdaptiveCommsComponent):
    """
    Given a routing list like this:
     [(MessageMatchingFunction, ComponentGenerator),
      ...
     ]
    routes incoming Messages by running every MessageMatchFunction on it.
    If any of the MessageMatchingFunctions returns True,
    1. A new Component is generated by the matching ComponentGenerator
    2. The PipeSelector ties this new component into a created message loop
    3. The component is activated and gets the message fed
    4. Upon producerFinished, the component will be torn down and links deleted
    5. Any resulting output will be sent to the PipeSelector's outbox

    *** NOTICE *************************************************************
    * Those pipes MUST finish in reasonable time, otherwise they get stopped
    and an unanswered request is the result!
    * The ComponentGenerator MUST be a callable, returning an AxonComponent
      or alike
    * The MessageMatchingFunction may be something like this:
      lambda x: x['foobar'] == 'bazqux' # TODO: Enhance this!
    ************************************************************************
    """

    Inboxes = {"inbox": "Items",
               "control": "Shutdown signalling",
    }
    Outboxes = {"outbox": "Items tagged with a sequence number, in the form (seqnum, item)",
                "signal": "Shutdown signalling",
    }

    def __init__(self, routes):
        super(PipeSelector, self).__init__()
        self.routes = routes  # [(condition, pipeline), ...]


    def finished(self):
        while self.dataReady("control"):
            msg = self.recv("control")
            if type(msg) in (shutdownMicroprocess):
                self.send(msg, "signal")
                return True
        return False

    def main(self):
        """Main loop."""

        while not self.finished():
            while not self.dataReady("inbox"):
                self.pause()
                yield 1
            data = self.recv("inbox")

            #log("[PS] data: ", data)

            for condition, pipegen in self.routes:
                if condition(data):
                    #log("[PS] Hit. Creating pipe.")

                    pipe = pipegen()

                    self.addOutbox(pipe.name)
                    self.addOutbox(pipe.name + "signal")
                    self.addInbox(pipe.name + "control")
                    self.addInbox(pipe.name + "inbox")

                    thetolink = self.link((self, pipe.name), (pipe, "inbox"))
                    thefromlink = self.link((pipe, "outbox"), (self, pipe.name + "inbox"))
                    thetosignal = self.link((self, pipe.name + "signal"), (pipe, "control"))
                    thefromsignal = self.link((pipe, "signal"), (self, pipe.name + "control"))

                    #log("[PS] Transmitting data to pipe:", data)
                    self.send(data, pipe.name)
                    pipe.activate()
                    self.send(producerFinished, pipe.name + "signal")

                    def clearLinks():
                        #log("[PS] Unlinking..")

                        self.unlink(pipe, thetolink)
                        self.unlink(pipe, thefromlink)
                        self.unlink(pipe, thetosignal)
                        self.unlink(pipe, thefromsignal)

                    begin = time.time()
                    #component(pipe)._callOnCloseDown.append(clearLinks)
                    #while (not component(pipe)._isStopped()) and (time.time() < begin + 5):
                    #    yield 1

                    while (not self.dataReady(pipe.name + "inbox")) and (time.time() < begin + 1):
                        yield 1

                    if self.dataReady(pipe.name + "inbox"):
                        self.send(self.recv(pipe.name + "inbox"), "outbox")
                    else:
                        log("[PS] WARNING: Pipe didn't respond in time: ", pipe.name, pipe)

                    #log("[PS] Pipe sent signal:", self.recv(pipe.name+"control")
                    #)
                    clearLinks()
                    component(pipe).closeDownComponent()
                    self.deleteOutbox(pipe.name)
                    self.deleteOutbox(pipe.name + "signal")
                    self.deleteInbox(pipe.name + "control")
                    self.deleteInbox(pipe.name + "inbox")

                    #log("[PS] Done.")


def testPipeSelector():
    from Kamaelia.Util.PureTransformer import PureTransformer

    def hitLine(hit):
        return (lambda x: x == hit, Pipeline(
            PureTransformer(lambda x: "YAY! Detected " + hit + " in " + str(x))
        )
        )

    rules = [hitLine("foo"),
             hitLine("bar")
    ]

    test = Pipeline(DataSource(["baz", "foo", "bar", "qux"]),
                    PipeSelector(rules),
                    PureTransformer(lambda x: "YAY! This is what you get:" + str(x)),
                    ConsoleEchoer()
    ).activate()